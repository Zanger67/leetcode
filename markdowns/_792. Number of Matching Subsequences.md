# 792. [Number of Matching Subsequences](<https://leetcode.com/problems/number-of-matching-subsequences>)

*All prompts are owned by LeetCode. To view the prompt, click the title link above.*

*[Back to top](<../README.md>)*

------

> *First completed : August 27, 2025*
>
> *Last updated : August 27, 2025*

------

> **Related Topics** : **[Array](<by_topic/Array.md>), [Hash Table](<by_topic/Hash Table.md>), [String](<by_topic/String.md>), [Binary Search](<by_topic/Binary Search.md>), [Dynamic Programming](<by_topic/Dynamic Programming.md>), [Trie](<by_topic/Trie.md>), [Sorting](<by_topic/Sorting.md>)**
>
> **Acceptance Rate** : **50.64 %**

------

> ## V1 DFS Parallel Index Tracking
> 
> Indexes the indices of each character in `s` and creates a trie of
> all potential subsequence words. Then, performs a DFS on the subsequence word trie while tracking the "last used index" of each character to see if each is valid.
> 
> Runtime: $O(s+w*v*s)$ where $s$ is the length of input string `s` and $w$ is the number of subsequence candidates in `words` and $v$ is the longest candidate in `words`.
> 
> ## V2 Trie-Merging Recursion
> 
> Converts potential subsequence word targets into a trie then iterates through each character of `s`. At each character `c`, if it's in the trie, we remove it and merge the subtrie into the main trie root. That is, we merge `trie[c]` into the root `trie` and recursively merge the branches. We use `trie['.']` to track how many word "endings" we have. Since we're systematically eliminating letters and summing `trie['.']` we return `'.'` which is our counter.
> 
> Runtime: $O(s)$ where $s$ is the length of the input string `s`.
> 

------

## Solutions

- [m792 v1 dfs parallel index tracking.py](<../my-submissions/m792 v1 dfs parallel index tracking.py>)
- [m792 v2 triemerging optimized.py](<../my-submissions/m792 v2 triemerging optimized.py>)
### Python
#### [m792 v1 dfs parallel index tracking.py](<../my-submissions/m792 v1 dfs parallel index tracking.py>)
```Python
class Solution:
    def numMatchingSubseq(self, s: str, words: List[str]) -> int:
        s_indxes = defaultdict(list)
        for i, c in enumerate(s) :
            s_indxes[c].append(i)

        trie = {}
        for w in words :
            curr = trie
            for c in w :
                if c not in curr :
                    curr[c] = {}
                curr = curr[c]
            # Mark ends of words; +1 in case there are repeats
            curr["."] = curr.get(".", 0) + 1

        return self._dfs_trie(trie, s_indxes, [0] * 26)

    def _dfs_trie(self, 
                  trie: Dict[str, dict], 
                  s_indxes: DefaultDict, 
                  c_indxes: List[int], 
                  curr_indx: int = -1) -> int :
        output = 0
        if "." in trie :
            output += trie["."]

        for nxt_c, nxt_trie in trie.items() :
            if nxt_c not in s_indxes :
                continue
            if nxt_c == "." :
                continue
            char_ord = ord(nxt_c) - ord('a')
            prev_reset = c_indxes[char_ord]

            if c_indxes[char_ord] >= len(s_indxes[nxt_c]) :
                continue

            while s_indxes[nxt_c][c_indxes[char_ord]] < curr_indx :
                c_indxes[char_ord] += 1
                if c_indxes[char_ord] >= len(s_indxes[nxt_c]) :
                    break

            if c_indxes[char_ord] >= len(s_indxes[nxt_c]) :
                c_indxes[char_ord] = prev_reset
                continue

            c_indxes[char_ord] += 1
            output += self._dfs_trie(
                nxt_trie, 
                s_indxes, 
                c_indxes, 
                s_indxes[nxt_c][c_indxes[char_ord] - 1] + 1
            )
            c_indxes[char_ord] = prev_reset

        return output
```

#### [m792 v2 triemerging optimized.py](<../my-submissions/m792 v2 triemerging optimized.py>)
```Python
class Solution:
    def numMatchingSubseq(self, s: str, words: List[str]) -> int:
        trie = {}
        for w in words :
            curr = trie
            for c in w :
                if c not in curr :
                    curr[c] = {}
                curr = curr[c]
            # Mark ends of words; +1 in case there are repeats
            curr["."] = curr.get(".", 0) + 1

        for c in s :
            if c not in trie :
                continue
            # Remove the char branch and merge its subtrie contents into main trie
            self._trie_merger_helper(trie, trie.pop(c))

        return trie['.']
            
    def _trie_merger_helper(self, trie1: Dict[str, dict], trie2: Dict[str, dict]) -> None :
        # Merge our "success" counter
        if '.' in trie2 :
            trie1['.'] = trie1.get('.', 0) + trie2.get('.', 0)
            trie2.pop('.')
        
        # Merge branches of trie
        for k, v in trie2.items() :
            if k not in trie1 : # If doesn't exist, we can reuse directly
                trie1[k] = v
                continue
            
            # Recurse into branches
            self._trie_merger_helper(trie1[k], trie2[k])
```

