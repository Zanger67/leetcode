# 3025. [Find the Number of Ways to Place People I](<https://leetcode.com/problems/find-the-number-of-ways-to-place-people-i>)

*All prompts are owned by LeetCode. To view the prompt, click the title link above.*

*[Back to top](<../README.md>)*

------

> *First completed : September 02, 2025*
>
> *Last updated : September 02, 2025*

------

> **Related Topics** : **[Array](<by_topic/Array.md>), [Math](<by_topic/Math.md>), [Geometry](<by_topic/Geometry.md>), [Sorting](<by_topic/Sorting.md>), [Enumeration](<by_topic/Enumeration.md>)**
>
> **Acceptance Rate** : **64.09 %**

------

> ## V1
> 
> Points sorted by $x$ then $-y$ since minimizing $x$ gives us the "leftmost" points and $-y$ gives us a secondary sorting based on the largest $y$ values. This lets us iterate and only check points right of a point in the list since any others are either left or above meaning the pairing has already been checked.
> 
> Since the points are sorted in such a manner, when comparing two points the only points that could be "between" are those between the two in the points[] array since values that are between $x$-wise will be sorted between them first and $y$-wise as a secondary case.
> 
> It basically allows us to auto-ignore any points found in quadrant-1 relative to the current top-left point (see below).
> 
> ```
> For (A, B)
> 
>     ||xxxxxxx|
>     ||xxxxxxx|
>     ||xxxxxxx|
>     ||xxxxxxx|
>     ||xxxxxxx|
>     ||-------A------------------
>     ||       |        |
>     ||       |--------B
>     ||       |
>     ||       |
> ====||========================
>     ||
>     ||
> ```
> 
> Given the sorting, we can ignore the xxx section.
> 
> ## V2
> 
> To optimize from V1, we can remove the check for $x$ since we've already sorted the array based on $x$.
> 
> We can also remove the iteration of `all(...)` since the sorted list means that points will be checked left to right, top to bottom. This means that any next point will expand rightwards or be equal rightwards (if equal, lower... meaning that it fails the empty space condition). The only farther right cases that are valid as you iterate are those that close the vertical gap since it prevents overlap. For instance, see the below:
> 
> ```
> For (A, B)
> 
>     ||       |
>     ||       |
>     ||       |
>     ||       |
>     ||       |
>     ||-------a-------------------------------
>     ||       |     |   |     |              |
>     ||       |     |   |     |--------------d
>     ||       |     |   |     |
>     ||       |     |   |-----c
>     ||       |     |   |
>     ||       |     |   |
>     ||       |     |---c
>     ||       |     |
>     ||       |-----b
>     ||       |
>     ||       |
> ====||======================================
>     ||
>     ||
> ```
> 

------

## Solutions

- [m3025 v1.py](<../my-submissions/m3025 v1.py>)
- [m3025 v2 optimized.py](<../my-submissions/m3025 v2 optimized.py>)
### Python
#### [m3025 v1.py](<../my-submissions/m3025 v1.py>)
```Python
class Solution:
    def numberOfPairs(self, points: List[List[int]]) -> int:
        points.sort(key=lambda x: (x[0], -x[1]))

        output = 0
        # Top left
        for i, (x1, y1) in enumerate(points) :
            # top right
            for j, (x2, y2) in enumerate(points[i + 1:], i + 1) :
                # valid pair
                if x2 < x1 or y2 > y1 :
                    continue
                # Check for "between" points
                if all(not (x1 <= x3 <= x2 and y2 <= y3 <= y1) for x3, y3 in points[i + 1:j]) :
                    output += 1

        return output
```

#### [m3025 v2 optimized.py](<../my-submissions/m3025 v2 optimized.py>)
```Python
class Solution:
    def numberOfPairs(self, points: List[List[int]]) -> int:
        points.sort(key=lambda x: (x[0], -x[1]))

        output = 0
        # Top left
        for i, (_, y1) in enumerate(points) :
            # top right
            min_y = -inf
            for j, (_, y2) in enumerate(points[i + 1:], i + 1) :
                if min_y < y2 <= y1 :
                    output += 1
                    min_y = y2
                    if y1 == min_y :
                        break

        return output
```

