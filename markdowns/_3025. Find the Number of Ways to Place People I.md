# 3025. [Find the Number of Ways to Place People I](<https://leetcode.com/problems/find-the-number-of-ways-to-place-people-i>)

*All prompts are owned by LeetCode. To view the prompt, click the title link above.*

*[Back to top](<../README.md>)*

------

> *First completed : September 02, 2025*
>
> *Last updated : September 02, 2025*

------

> **Related Topics** : **[Array](<by_topic/Array.md>), [Math](<by_topic/Math.md>), [Geometry](<by_topic/Geometry.md>), [Sorting](<by_topic/Sorting.md>), [Enumeration](<by_topic/Enumeration.md>)**
>
> **Acceptance Rate** : **41.12 %**

------

> Points sorted by $x$ then $-y$ since minimizing $x$ gives us the "leftmost" points and $-y$ gives us a secondary sorting based on the largest $y$ values. This lets us iterate and only check points right of a point in the list since any others are either left or above meaning the pairing has already been checked.
> 
> Since the points are sorted in such a manner, when comparing two points the only points that could be "between" are those between the two in the points[] array since values that are between $x$-wise will be sorted between them first and $y$-wise as a secondary case.
> 

------

## Solutions

- [m3025.py](<../my-submissions/m3025.py>)
### Python
#### [m3025.py](<../my-submissions/m3025.py>)
```Python
class Solution:
    def numberOfPairs(self, points: List[List[int]]) -> int:
        points.sort(key=lambda x: (x[0], -x[1]))

        output = 0
        # Top left
        for i, (x1, y1) in enumerate(points) :
            # top right
            for j, (x2, y2) in enumerate(points[i + 1:], i + 1) :
                # valid pair
                if x2 < x1 or y2 > y1 :
                    continue
                # Check for "between" points
                if all(not (x1 <= x3 <= x2 and y2 <= y3 <= y1) for x3, y3 in points[i + 1:j]) :
                    output += 1

        return output
```

