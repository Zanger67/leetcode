# 3461. [Check If Digits Are Equal in String After Operations I](<https://leetcode.com/problems/check-if-digits-are-equal-in-string-after-operations-i>)

*All prompts are owned by LeetCode. To view the prompt, click the title link above.*

*[Back to top](<../README.md>)*

------

> *First completed : October 23, 2025*
>
> *Last updated : October 24, 2025*

------

> **Related Topics** : **[Math](<by_topic/Math.md>), [String](<by_topic/String.md>), [Simulation](<by_topic/Simulation.md>), [Combinatorics](<by_topic/Combinatorics.md>), [Number Theory](<by_topic/Number Theory.md>)**
>
> **Acceptance Rate** : **82.49 %**

------

> ## Notes
> 
> ### V1/V2
> 
> Simulation method -- inefficient but accepted.
> 
> ### V3 and above
> 
> Combinatorics to create an $O(n)$ solution.
> 
> Breaking down examples we have the following scratch calculations...
> 
> ```
> s="12345"
> 
> 1 2 3 4 5
> 3 5 7 9
> (1+2)mod10 (2+3)mod10 (3+4)mod10 (4+5)mod10
> 
> 8 12 16
> 8 2 6
> 
> ((1+2)mod10+(2+3)mod10)mod10 ((2+3)mod10+(3+4)mod10)mod10
> ((3+4)mod10+(4+5)mod10)mod10
> 
> (1+2+2+3)mod10 (2+3+3+4)mod10
> (3+4+4+5)mod10
> 
> (1+2+2+2+3+3+3+4)mod10 (2+3+3+3+4+4+4+5)mod10
> 
> (1+2+2+2+3+3+3+4+2+3+3+3+4+4+4+5)mod10
> (1+2+2+2+2+3+3+3+3+3+3+4+4+4+4+5)mod10
> (1*1+4*2+6*3+3*4+1*5)mod10 = 44 => TRUE
> (1*a[0]+4*a[1]+6*a[2]+3*a[3]+1*a[4])mod10
> 
> (1*a[0]+4*a[1]+6*a[2]+3*a[3]+1\*a[4])mod10
> 
> This works for this case of 12345
> 
> 3902
> 3 9 0 2
> 12 9 2
> 2 9 2
> 
> 11 11
> 1 1 => TRUE
> 
> 3 9 0 2
> (3+9)mod10 (9+0)mod10 (0+2)mod10
> (3+9+9+0)mod10 (9+0+0+2)mod10 = 21mod10 11mod10 = 1 1 => TRUE => CORRECT
> (1*a[0]+2*a[1]+1\*a[2])
> 
> (3+9+9+0+9+0+0+2)mod10
> = 32 => FALSE => WRONG
> 
> We find an edge case if we go all the way. However, if we stop one step before... we can compare their digit vals.
> 
> Seems like we should stop a step before and perform our comparison?
> 2 operations of O(n)
> ```
> 

------

## Solutions

- [e3461 v1.py](<../my-submissions/e3461 v1.py>)
- [e3461 v2.py](<../my-submissions/e3461 v2.py>)
- [e3461 v3 combinatorics O(n).py](<../my-submissions/e3461 v3 combinatorics O(n).py>)
- [e3461 v4.py](<../my-submissions/e3461 v4.py>)
### Python
#### [e3461 v1.py](<../my-submissions/e3461 v1.py>)
```Python
class Solution:
    def hasSameDigits(self, s: str) -> bool:
        while len(s) > 2 :
            s_n = []
            for x, y in zip(s[:-1], s[1:]) :
                s_n.append(str((int(x) + int(y)) % 10))
            s = ''.join(s_n)
        
        return s[0] == s[1]
```

#### [e3461 v2.py](<../my-submissions/e3461 v2.py>)
```Python
class Solution:
    def hasSameDigits(self, s: str) -> bool:
        while len(s) > 2 :
            s = ''.join([str((int(x) + int(y)) % 10) for x, y in zip(s[:-1], s[1:])])
        return s[0] == s[1]
```

#### [e3461 v3 combinatorics O(n).py](<../my-submissions/e3461 v3 combinatorics O(n).py>)
```Python
class Solution:
    def hasSameDigits(self, s: str) -> bool:
        a, b = 0, 0
        x = len(s) - 2
        for i, num in enumerate(s[:-1]) :
            a += (int(num) * comb(x, i)) % 10
        for i, num in enumerate(s[1:]) :
            b += (int(num) * comb(x, i)) % 10
        return a % 10 == b % 10
```

#### [e3461 v4.py](<../my-submissions/e3461 v4.py>)
```Python
class Solution:
    def hasSameDigits(self, s: str) -> bool:
        x = len(s) - 2
        a = sum((int(num) * comb(x, i)) % 10 for i, num in enumerate(s[:-1])) % 10
        b = sum((int(num) * comb(x, i)) % 10 for i, num in enumerate(s[1:])) % 10
        return a == b
```

