# 1182. [Shortest Distance to Target Color](<https://leetcode.com/problems/shortest-distance-to-target-color>)

*All prompts are owned by LeetCode. To view the prompt, click the title link above.*

*[Back to top](<../README.md>)*

------

> *First completed : August 29, 2025*
>
> *Last updated : August 29, 2025*

------

> **Related Topics** : **[Array](<by_topic/Array.md>), [Binary Search](<by_topic/Binary Search.md>), [Dynamic Programming](<by_topic/Dynamic Programming.md>)**
>
> **Acceptance Rate** : **56.29 %**

------

> ## V1 Fuzzy Binary Search
> 
> Stored where each color appeared in sorted order then used binary search to approximately find where the value would be. Checked for the min difference for the found index j +/- 1 in case the exact value wasn't found (min_distance(arr[j - 1:j+1]) inclusive).
> 

------

## Solutions

- [m1182 v1.py](<../my-submissions/m1182 v1.py>)
- [m1182 v2 precomputation.py](<../my-submissions/m1182 v2 precomputation.py>)
### Python
#### [m1182 v1.py](<../my-submissions/m1182 v1.py>)
```Python
class Solution:
    def shortestDistanceColor(self, colors: List[int], queries: List[List[int]]) -> List[int]:
        indices = {1: [], 2: [], 3:[]}
        for i, c in enumerate(colors) :
            indices[c].append(i)

        return [
            0 if colors[i] == c else self._bin_search_closest(indices[c], i)
            for i, c in queries
        ]

    def _bin_search_closest(self, arr: List[int], target_indx: int) -> int :
        if not arr :
            return -1
        l, r = 0, len(arr) - 1

        while l < r :
            mid = (l + r) // 2
            mid_val = arr[mid]
            if mid_val == target_indx :
                return 0
            if mid_val > target_indx :
                r = mid - 1
                continue
            l = mid + 1

        # Fuzzy bound so check +/- 1 index to see if it's an approximation
        return min(abs(target_indx - x) for x in arr[max(0, l - 1):min(len(arr), r + 2)])
```

#### [m1182 v2 precomputation.py](<../my-submissions/m1182 v2 precomputation.py>)
```Python
class Solution:
    def shortestDistanceColor(self, colors: List[int], queries: List[List[int]]) -> List[int]:
        precomp = [[inf] * len(colors) for _ in range(3)]

        closest = [inf, inf, inf]
        for i, c in enumerate(colors) :
            closest[c - 1] = i
            precomp[0][i] = abs(i - closest[0])
            precomp[1][i] = abs(i - closest[1])
            precomp[2][i] = abs(i - closest[2])
        
        closest = [inf, inf, inf]
        for i in range(len(colors) - 1, -1, -1) :
            closest[colors[i] - 1] = i
            precomp[0][i] = min(precomp[0][i], closest[0] - i)
            precomp[1][i] = min(precomp[1][i], closest[1] - i)
            precomp[2][i] = min(precomp[2][i], closest[2] - i)
        
        for r in precomp :
            for i in range(len(r)) :
                if r[i] == inf :
                    r[i] = -1
        
        return [precomp[c - 1][x] for x, c in queries]
```

