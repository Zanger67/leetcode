# 1182. [Shortest Distance to Target Color](<https://leetcode.com/problems/shortest-distance-to-target-color>)

*All prompts are owned by LeetCode. To view the prompt, click the title link above.*

*[Back to top](<../README.md>)*

------

> *First completed : August 29, 2025*
>
> *Last updated : August 29, 2025*

------

> **Related Topics** : **[Array](<by_topic/Array.md>), [Binary Search](<by_topic/Binary Search.md>), [Dynamic Programming](<by_topic/Dynamic Programming.md>)**
>
> **Acceptance Rate** : **55.54 %**

------

> ## V1 Fuzzy Binary Search
> 
> Stored where each color appeared in sorted order then used binary search to approximately find where the value would be. Checked for the min difference for the found index j +/- 1 in case the exact value wasn't found (min_distance(arr[j - 1:j+1]) inclusive).
> 

------

## Solutions

- [m1182 v1.py](<../my-submissions/m1182 v1.py>)
### Python
#### [m1182 v1.py](<../my-submissions/m1182 v1.py>)
```Python
class Solution:
    def shortestDistanceColor(self, colors: List[int], queries: List[List[int]]) -> List[int]:
        indices = {1: [], 2: [], 3:[]}
        for i, c in enumerate(colors) :
            indices[c].append(i)

        return [
            0 if colors[i] == c else self._bin_search_closest(indices[c], i)
            for i, c in queries
        ]

    def _bin_search_closest(self, arr: List[int], target_indx: int) -> int :
        if not arr :
            return -1
        l, r = 0, len(arr) - 1

        while l < r :
            mid = (l + r) // 2
            mid_val = arr[mid]
            if mid_val == target_indx :
                return 0
            if mid_val > target_indx :
                r = mid - 1
                continue
            l = mid + 1

        # Fuzzy bound so check +/- 1 index to see if it's an approximation
        return min(abs(target_indx - x) for x in arr[max(0, l - 1):min(len(arr), r + 2)])
```

