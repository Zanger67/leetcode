# 3213. [Construct String with Minimum Cost](<https://leetcode.com/problems/construct-string-with-minimum-cost>)

*All prompts are owned by LeetCode. To view the prompt, click the title link above.*

*Completed during Weekly Contest 405 (q4)*

*[Back to top](<../README.md>)*

------

> *First completed : July 10, 2024*
>
> *Last updated : July 10, 2024*

------

> **Related Topics** : **N/A**
>
> **Acceptance Rate** : **15.413 %**

------

## Solutions

- [Weekly Contest 405/h3213 q4 v2 DP + Trie.py](<../my-submissions/Weekly Contest 405/h3213 q4 v2 DP + Trie.py>)
- [Weekly Contest 405/h3213 q4.py](<../my-submissions/Weekly Contest 405/h3213 q4.py>)
### Python
#### [h3213 q4 v2 DP + Trie.py](<../my-submissions/Weekly Contest 405/h3213 q4 v2 DP + Trie.py>)
```Python
class Solution:
    def minimumCost(self, target: str, words: List[str], costs: List[int]) -> int:
        # Generate trie
        trie = {}
        for cost, word in zip(costs, words) :
            curr = trie
            for c in word :
                if c not in curr :
                    curr[c] = {}
                curr = curr[c]
            # If identical word exists, use smallest cost
            curr[False] = min(curr.get(False, inf), cost)

        # Dynamic Programming array
        dp = [0] + [inf] * len(target)

        # Iterate through each 
        for i in range(len(target)) :
            curr = trie
            offset = 0
            while i + offset < len(target) and target[i + offset] in curr  :
                curr = curr[target[i + offset]]
                offset += 1

                # Word ends
                if False in curr :
                    dp[i + offset] = min(dp[i + offset], dp[i] + curr[False])

        # -1 if end was not reachable
        return -1 if dp[-1] == inf else dp[-1] 

```

#### [h3213 q4.py](<../my-submissions/Weekly Contest 405/h3213 q4.py>)
```Python
class Solution:
    def minimumCost(self, target: str, words: List[str], costs: List[int]) -> int:
        wordToCost = Counter()
        for w, c in zip(words, costs) :
            # Always take the lowest cost case
            if w in wordToCost and wordToCost[w] <= c :
                continue
            wordToCost[w] = c

        # Remove duplicates from being checked
        words = sorted(set(words), key=lambda x: len(x))
        maxWrd = len(words) - 1

        dp = [0] + [inf] * len(target)

        for i in range(len(target)) :
            while maxWrd >= 0 and len(words[maxWrd]) > len(target) - i :
                maxWrd -= 1
            if maxWrd < 0 :
                break

            for word in words[:maxWrd + 1] :
                if word == target[i:i+len(word)] :
                    dp[i + len(word)] = min(dp[i + len(word)], dp[i] + wordToCost[word])

        return -1 if dp[-1] == inf else dp[-1] 

```

