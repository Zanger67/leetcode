While the brute-force solution would have likely worked, checking if arr\[x:x+k\] then if arr\[x + k:x+2k\] would work, incrementing by one index if it fails, I wanted to pursue a more optimal pathway.

Instead of checking each paired of sub-arrays, we can adjust our jump lengths.

-   For the first subarray, we can jump past the failed subarray if it fails.
-   For the second subarray, if the connection between the two subarrays is also strictly increasing (last term in arr1 is less than the first of arr2), we can jump to align the first array with the ending of the second's failing point. Otherwise, we adjust like usual.

E.g.

```
k = 3
[3 2 1 2 3  7 8  8 9 10 11]
    [1 2 3][7 8] failed
        [3  7 8] set left as this -- no need to double verify
        [3  7 8][8 9 10] FOUND return True
```

### Versions

1. V1: index based jumping
2. V2: iterating and counter tracking
